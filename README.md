# HOOK 简介

HOOK 是 React16.8.0 之后出现

组件：无状态组件(函数组件)，类组件

类组件中的麻烦:

1. this 指向问题
2. 繁琐的声明周期
3. 其他问题

HOOK 专门用于增强函数组件的功能(只能在函数里面使用)，使之理论可以上可以成为类组件的替代品

HOOK 本质上是一个函数，以 use 开头，该函数可以挂载任何东西

# State HOOK

State HOOK 是一个在函数组件中使用的函数

- useState 函数有一个参数，这个参数的值表示状态的默认值
- 函数的返回值是一个数组，该数组一定包含两项，
  - 第一项是当前状态的值
  - 第二项是一个改变状态值的函数

一个函数组件中可以有多个状态

## State Hook 原理

每个函数都有自己相应的状态数组
第 N 次运行 useState, 在 N-1 下标中查看是否有该状态，若没有则添加默认值，若有则忽略默认值

**注意的细节**

1. useState 最好写在函数起始位置，便于阅读
2. useState 严禁出现在代码块(判断，循环)中（改变状态后，状态数组中可能会错位）
3. useState 返回的函数(数组的第二项)，引用不变，节约内存空间
4. 如果使用函数改变数据，若数据和之前的数据完全相等(使用 Object.is 比较)如果相等不会导致重新渲染，已达到优化效率的目的
5. 使用函数改变数据，传入的值不会和原来的数据合并，而是直接替换
6. 如果需要强制刷新
   1. 类组件使用 this.forceUpdate 函数, 不会运行 shouldComponentUpdate
   2. 函数组件，使用一个空对象的 useState
7. 如果某些状态之间没有必然的联系，应该分化为不同的状态，而不是合并成一个对象
8. 和类组件的状态一样，函数组件中改变状态可能是异步的,多个状态改变会合并以提高效率，此时不能信任之前的状态，而应该使用回调函数的方式改变状态，如果状态变化后要使用之前的状态应尽量传递函数

# Effect HOOK

只传入一个函数，每次重写渲染都会运行 Effect
用于处理函数组件中的副作用
副作用：

1. ajax 请求
2. 计时
3. 以及其他会对外部产生影响的操作

函数，该函数接受一个函数作为参数，接受的函数就是进行副作用操作的函数 useEffect(()=>{
....
})

**细节**

1. 副作用函数的运行时间点，是在页面完成真实的 ui 渲染之后，因此它的执行是异步的，不会阻塞浏览器
   1. 与类组件中 componentDidMount 和 componentDidUpdate 的区别，它们都可以做副操作，这两个函数是修改了真实的 dom 之后，页面还没有更新，就开始运行这两个函数
   2. useEffect 中的副作用函数，更改了真实 dom，并且用户已经看到了 ui 界面的更新，才会运行，即不会阻塞 ui 界面的更新
2. 每个函数组件中可以使用多次 useEffect,但是不要放在 for if 中
3. useEffect 中的副作用函数，可以有返回值，返回值必须是一个函数，该函数叫做清理函数
   1. 该函数运行时间点，在每次运行副作用函数之前，先运行返回函数
   2. 首次渲染组件不会运行
   3. 组件被销毁时，一定会运行且只会运行清理函数
4. useEffect 可以传递第二个参数，
   1. 第二个参数是一个数组（加个空数组即没有依赖项，每次认为什么也没有变）
   2. 数组中记录该副作用的依赖数据
   3. 当组件重新渲染后，只有依赖数据与上一次不一样时，才会执行副作用
   4. 所以，当传递了依赖数据之后，如果数据没有发生变化
      1. 副作用函数仅在第一次渲染后运行
      2. 清理函数仅在卸载组件后运行
5. 副作用函数中，如果使用了函数上下文中的变量，则由于闭包的影响，会导致作用函数中的变量不会实时变化(每次渲染是该次渲染的值)
6. 副作用函数在每次注册时，会覆盖之前的副作用函数，因此尽量保持副作用函数稳定，否则控制起来会比较复杂

# 自定义 HOOK

自定义 Hook：将一些常用的，跨越多个组件的 Hook 功能，抽离出去形成一个函数，，该函数就是自定义 Hook
，自定义 Hook，由于其内部需要使用 hook 功能名，所以它本身也需要按照 hook 的规则实现

1. 函数名必须以 use 开头
2. 调用自定义 hook 函数时，应该放到顶层
   > 使用 Hook 的时候，如果没有严格按照 hook 的规则进行，eslint 的一个插件会报出警告
   > （eslint-plugin-react-hooks）

# Reducer Hook

useReducer react 提供的 reducer

1. 参数 1 reducer
2. 参数 2 初始状态
3. 函数 将函数的返回结果来作为初始值，第二个值作为参数传入到函数里面

# Context Hook

用于获取上下文数据

# Callback hook

用于得到一个固定引用值的函数，通常用于性能优化
useCallback:

1. 参数 1，函数，useCalllback 会固定该函数的引用，只要依赖项没有发生变化,则始终返回之前函数的地址
2. 数组，记录依赖项
   该函数返回：引用相对固定的函数地址

# Memo Hook

用于保持一些比较稳定的数据，通常用于性能优化
**如果 React 元素本身的引用没有发生变化，一定不会重新渲染**

# Ref Hook

useRef 函数：

1. 一个参数：默认值
2. 返回一个固定的对象 `{current:data}`

# ImperativeHandle Hook

函数：useImperativeHandleHook

1. 参数 1，转发过来的 ref
2. 参数 2，函数，将返回过来的 data 放入{current:data}
3. 参数 3，依赖项[],如果数据没有发生变化则不会调用参数 2，首次调用

# LayoutEffect Hook

useEffect: 浏览器渲染完成后，用户看到新的渲染结果之后(所以不要在里面改变 dom)
useLayoutEffectHook，componentDidMount,comoponentDidUpdate:浏览器完成 dom 修改，但还没有呈现给用户

应该尽量使用 useEffect,因为不会阻塞渲染

# DebugValue Hook

useDebugValue:用于将自定义 hook 的关联数据显示到调试栏
