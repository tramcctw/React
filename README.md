# Context

上下文:Context,表示做某一些事情的环境

React中的上下文特点
1. 当某个组件创建了上下文后，上下文中的数据，会被所有后代组件共享
2. 如果某个组件依赖上下文，会导致该组件不再纯粹(外来数据仅来源于属性props)
3. 一般用于第三方组件（通用组件）

## 旧的API

**创建上下文**
只有类组件才可以创建上下文(自己无法取到自己的上下文，且就近取上下文)
1. 给类组件写静态属性，childContextTypes，使用该属性对上下文中的数据进行类型约束
2. 添加实例方法 getChildContext ,该方法返回的对象，即为上下文中的数据，该数据必须满足类型约束，该方法会在每次render之后运行


**使用上下文中的数据**

要求:如果要使用上下文中的数据，组件必须有一个静态属性，contextTypes,该属性描述了需要获取的上下文中的数据类型

1. 可以在组件的构造函数中(但是构造函数只会运行一次)，通过第二个参数获得上下文数据
2. **从组件的context属性中获取(this.context)**
3. 在函数组件中，通过第二个参数，获取上下文数据

**上下文的数据变化**
上下文的数据不可以直接变化，最终都是状态改变
在上下文中加一个处理函数，可以用于后代组件更改上下文中的数据



# 新版API
旧版API存在严重的效率问题，并且容易导致滥用


**创建上下文**

上下文是一个独立于组件的对象，通过React.createContext()创建
返回一个包含两个属性的对象
1. Provider属性：生产者一个组件,该组件会创建一个上下文
    1. 同一个Provider不要用在多个组件中，如果另一个组件也需要用到该数据
        应该考虑将数据提升到更高的层次
2. Consumer属性:

**使用上下文中的数据**

1. 在类组件中，直接使用this.context获取上下文数据
    1. 要求：必须拥有静态属性：contextType,应赋值为创建的上下文对象
2. 在函数组件中，需要属于Consumer来获取上下文数据(类组件也可以使用这种方式)
    1. Consumner是一个组件
    2. 它的子节点是一个函数（它的props.children需要传递一个函数）函数的参数即为上下文

**注意细节**
如果，上下文提供者（Context.Provider）中的value属性发生变化（地址不一样），会导致该上下文提供的所有后代元素全部重新渲染，无论该子元素是否优化（无论shouldComponentUpdate函数返回什么结果（绕过））
value赋值state，而this.setState({})状态没有发生变化，但是state的地址发生了不变化，就会重新render，使用Object.is比较
