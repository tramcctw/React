# 利用中间件进行副作用处理

- redux-thunk

thunk 允许 action 是一个带有副作用的函数，当 action 是一个函数被分发时,thunk 会阻止 action 继续向后分发，并运行函数，否则向后分发

thunk 会向函数中传递三个参数

- dispatch:来自于 store.dispatch
- getState:来自于 store.getState
- extra:来自于用户设置的额外参数

- redux-promise

## 迭代

类似于遍历
遍历：由多个数据组成的集合数据结构，需要从中依次取出数据进行某种处理

迭代：按照某种逻辑，依次取出下一个数据进行处理

## 迭代器

js 语言规定，如果一个对象具有 next 方法，并且 next 方法满足一定的约束，该对象就是一个迭代器(iterator)

next 方法的约束，该方法必须返回一个对象，该对象至少有两个属性

- value: any 类型 下一个数据的值 done 为 true 通常设置 value 为 undefined
- done: bool 类型 是否已经迭代完成

通过迭代器的 next 方法，可以依次取出数据，并可以根据返回的 done 属性，判断是否迭代结束

### 迭代器创建函数 iterator creator
它是指一个函数，调用该函数后，返回一个迭代器，则该函数称之为迭代器创建函数，可以简称迭代器函数


## 可迭代协议
es6中出现for-of 循环，该循环就是用于迭代某个对象的，因此，for-of循环要求对象必须是可迭代的(对象必须满足可迭代协议)

可迭代协议是用于约束一个对象的，如果一个对象满足下面的规范，则该对象满足可迭代协议，也称之为该对象是可以被迭代的

可迭代协议的约束如下：
1. 对象必须有一个知名符号属性(Symbol.iterator)
2. 该属性必须是一个无参的迭代创建函数


## for-of循环的原理
调用对象的[Symbol.iterator]方法，得到一个迭代器，不断调用next方法，只要返回的done为false，则将返回的value传递给变量，然后进入循环体执行一次。数组等也遵守可迭代协议 



# 生成器 generator
## generator
生成器：由构造函数Generator创建的对象，该对象既是一个迭代器，同时，又是一个可迭代对象

**注意：Generator构造函数，不提供给开发者使用，仅作为js引擎内部使用**

## generator function
生成器创建函数：该函数用于创建一个生成器
es6新增了一个特殊的函数，叫做生成器函数，只要在函数与function关键字之间加上一个*，则该函数会自动返回一个生成器

生成器函数的特点：
1. 调用生成器函数会返回一个生成器，而不是执行函数体(因为生成器函数的函数体执行，受到生成器控制)
2. 每当调用了生成器的next方法，生成器的函数体会从上一次yield结束的位置(或函数开始位置)运行到下一个yield结束
    1. yield的关键字只能在生成器函数内部使用
    2. 它表示暂停，并返回一个当前迭代的数据
    3. 如果没有下一个yield,到函数结束，则生成器的next方法得到的结果中done为true
3. yield关键字后面的表达式返回的数据，会作为当前迭代的数据
4. 生成器函数的返回值，会作为迭代结束的value
    1. 但是，如果结束后仍然next则value为undefined
5. 生成器调用next的时候，可以传递参数，该参数会作为生成器函数体
上一次yield表达式的值。
    1. 生成器第一调用next函数时，传递参数没有意义。
6. 生成器带有一个throw方法，该方法与next效果相同，唯一的区别在于：
    1. next方法传递的参数会被返回成一个正常值
    2. throw方法传递的参数是一个错误，会导致生成器函数内部发生一个错误
    3. 生成器带有一个return方法，该方法会直接结束生成器函数
7. 若需要在生成器内部调用其他生成器，注意：如果直接调用，得到的是一个生成器，如果加入```yield* func()```调用，则进入其他生成器内部执行，返回值为函数的返回值。

- redux-saga
